---
layout: post
title: "Architecture Hexagonale"
category: DDD
tags:
  - cqrs
  - hexagonale
  - architecture
published: false
comments: true
excerpt: |
  Que l'on traduira (maladroitement) comme suit:

---

notextile.. <style>
	.collapsible .content {
		display:none;
	}

	.collapsible h3 a {
		color:gray;
		font-style:italic;
	}

	.collapsible h3 {
		line-height:12px;
		font-size:8px;
		padding: 0px; 
		cursor:pointer; 
		background-color: #eee;
		display:block; 
		text-decoration:none; 
		margin:0; 
		margin-top:10px;
	}
	.collapsible h3:after {
		content:" (click to open/close)";
		color:slategray;
		letter-spacing:.2em;
		font-size:6pt;
	}
	.active {
		background-color: #ddd;  
	}

</style>
<script type="text/javascript">
	$(function() {
		$("section.original").wrap('<div class="collapsible" />');
		$("section.original").parent().prepend("<h3>Original</h3>");
		$(".collapsible").collapse({
			group: "div,ul,section"
		});
	});
</script>

<span class="label warning">In Progress // Incubation</span><br/>

<div class="collapsible">
<h3>Notes</h3>
<div class="content">

http://matteo.vaccari.name/blog/archives/154

<blockquote><p>La conception pilotée par le domaine (Domain-driven design, DDD) est une approche de développement logiciel adaptée aux besoins complexes dont l'idée est de connecter fortement l'implémentation d'un modèle aux concepts métiers associés. L'approche est basée sur les principes suivants :

<ul>
<li>Mettre l'emphase du projet sur sur le domaine et la logique métier ;</li>
<li>Baser les conceptions complexes sur un modèle ;</li>
<li>Initier la collaboration créative entre les experts techniques et du domaine dans le but de s'approcher itérativement du coeur conceptuel du problème.</li>
</ul>

La conception pilotée par le domaine n'est ni une technologie, ni une méthodologie. DDD fournit une structure de pratiques et une terminologie pour effectuer des choix de conception qui mettent l'accent et accélèrent les projets associés à des domaines complexes.

Les concepts introduits dans le livre Domain-Driven Design de Eric Evan's incluent :

<ul>
<li>Langage ubiquitaire (Ubiquitous Language)</li>
<li>Conception orientée domaine (Model-Driven Design)
	<ul>
		<li>Architecture à Couche (Layered Architecture)</li>
		<li>Entités (Entities)</li>
		<li>Objet valeur (Value Objects)</li>
		<li>Service (Services)</li>
		<li>Modules</li>
		<li>Aggrégats (Aggregates)</li>
		<li>Fabriques (Factories)</li>
		<li>Dépôts (Repositories)</li>
	</ul>
</li>
<li>Remaniement vers un insight plus profond (Refactoring toward deeper insight)</li>
<li>Préservation de l'intégrité du modèle à travers la conception stratégique (Strategic Design)
	<ul>
		<li>Limite de contexte (Bounded Countext)</li>
		<li>Intégration continue (Continuous Integration)</li>
		<li>Carte de contexte (Context Map)</li>
		<li>Noyau partagé (Shared Kernel)</li>
		<li>Client-fournisseur (Customer-Supplier)</li>
		<li>Conformisme (Conformist)</li>
		<li>Couche d'anti-corruption (Anticorruption Layer)</li>
		<ul>
			<li>Différents chemins (Separate Ways)</li>
		</ul>
		<li>Service d'hôte ouvert (Open Host Service)</li>
		<li>Distillation</li>
	</ul>
</li>
</ul>

L'architecture hexagonale de Alistair Cockburn est une référence intéressante à consulter lors de l'implémentation de systèmes utilisant l'approche DDD.
</p><small>"Pyxis - Conception pilotée par le domaine (DDD)":http://pyxis-tech.com/fr/expertise/conception-pilotee-par-le-domaine-ddd
</small></blockquote>

</div> <!-- content -->
</div> <!-- collapsible -->

h1. The Pattern: Ports and Adapters ("Object Structural") ("Source":http://alistair.cockburn.us/Hexagonal+architecture)

__Cet article se veux une tentative de traduction en français de l'article de Alistair Cockburn.__

notextile.. <style>
	.original,
	.original h1,
	.original h2,
	.original h3,
	.original h4,
	.original p,
	.original p em {
		color: #7A5607;
	}
	.original ul li {
		color: #8C6208;/*lighter*/
		font-weight:lighter;
	}

	.google_trad,
	.google_trad ul li {
		font-style: italic;
		color: gray;
	}

	.yahoo_trad,
	.yahoo_trad ul li {
		font-style: italic;
		color: #A2B6DB;
	}

	.trad,
	.trad ul li {
		color: black;
	}

	section.body {
		position:relative;
	}
	.sidenote {
		position: absolute;
		right:-220px;
		width:200px;
		border: #A2B6DB;
		float: right;
	}

</style>

<div class="collapsible">
<h3>Original</h3>
<div class="content original">
<h2>The Pattern: Ports and Adapters (&#8216;&#8217;Object Structural&#8217;&#8217;) </h2>
</div>
</div>

<section class="trad">

h2. Le Motif: Ports[1] et Adaptateurs[2] (&#8216;&#8216;Motif Structurel&#8217;&#8217;) </h2>

<div class="sidenote">
fn1. <b>Un port</b> est un point d'entrée/sortie vers un autre dispositif, permettant à un client d'utiliser une application (ou un service).

fn2. <b>Adaptateur</b> est un patron de conception de type structure. <small>Il permet de convertir l'interface d'une classe en une autre interface que le client attend. L' Adaptateur fait fonctionner un ensemble des classes qui n'auraient pas pu fonctionner sans lui, à cause d'une incompatibilité d'interfaces.</small>
</div>
</section>

<section class="original">
<p><em>Create your application to work without either a UI or a database so you can run automated regression-tests against the application, work when the database becomes unavailable, and link applications together without any user involvement.</em></p>
</section>

<section class="trad">
<p><em>Créer votre application de sorte qu'elle puisse fonctionner sans interface utilisateur ni base de données, qu'il soit possible de lancer automatiquement des tests de non-regression sollicitant l'application, de travailler même lorsque la base de données est indisponible, et pouvoir connecter les applications les unes aux autres sans  intervention spécifique.</em></p>
</section>

<section class="original">
<h3>Alternative name: &#8216;&#8217;Hexagonal Architecture&#8217;&#8217; </h3>
</section>

<section class="trad">
<h3>Autre nom: &#8216;&#8216;Architecture Hexagonale&#8217;&#8217; </h3>
</section>

<section class="original">
<h3>Intent </h3>
</section>

<section class="trad">
<h3>But </h3>
</section>

<section class="original">
<p>Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases.</p>
</section>

<section class="trad">
<p>Permettre à une application d'être sollicitée de la même manière par des utilisateurs, des programmes, des tests automatisés ou des scripts, et d'être développée et testée de manière isolée d'éventuels dispositifs et bases de données présents à l'execution.</p>
</section>

<section class="original">
<p>As events arrive from the outside world at a port, a technology-specific adapter converts it into a usable procedure call or message and passes it to the application. The application is blissfully ignorant of the nature of the input device. When the application has something to send out, it sends it out through a port to an adapter, which creates the appropriate signals needed by the receiving technology (human or automated). The application has a semantically sound interaction with the adapters on all sides of it, without actually knowing the nature of the things on the other side of the adapters.</p>
</section>

<section class="trad">
<p>Comme les évènements arrivent de l'exterieur via un point d'entrée (__port__[1]), un adaptateur[2] spécifique les transforme en des appels de fonction ou des messages exploitables avant de les transmettre à l'application. L'application est, et ce avec un grand bonheur, complétement ignorante de la nature du dispositif qui la sollicite. Lorsque l'application a quelque chose à emettre, elle l'envoie à travers un point de sortie (__port__[1]) à un adaptateur[2] qui créé le signal approprié requis par la technologie qui va le receptionner (humain ou automate). L'application a ainsi une interaction sémantiquement saine avec les adaptateurs de part et d'autre, sans connaître réellement la nature des choses qui se trouvent de l'autre côtés des adaptateurs.</p>
</section>

<p><img src='/images/hexagonal-architecture/2301' alt='Image176.gif' title='Image176.gif' /><br /><br />
 Figure 1</p>

<section class="original">
<h3>Motivation </h3>
</section>

<section class="trad">
<h3>Motivation </h3>
</section>

<section class="original">
<p>One of the great bugaboos of software applications over the years has been infiltration of business logic into the user interface code. The problem this causes is threefold: <br />
<ul>
<li>First, the system can&#8217;t neatly be tested with automated test suites because part of the logic needing to be tested is dependent on oft-changing visual details such as field size and button placement; </li>
<li>For the exact same reason, it becomes impossible to shift from a human-driven use of the system to a batch-run system; </li>
<li>For still the same reason, it becomes difficult or impossible to allow the program to be driven by another program when that becomes attractive.</li>
</ul>
</p>
</section>

<section class="trad">
<div class="sidenote">
fn3. <quote>Bugaboo: An imaginary monster used to frighten children.</quote> <small>traduit en “Croque-mitaines”</small>
</div>
<p>L'un des plus terribles Croque-mitaines[3] des applications logicielles au fil des années a été l'infiltration de la logique métier dans le code de l'interface utilisateur. Les problèmes que cela cause sont triples: <br/>
<li>Premièrement, le système ne peux pas être complètement testé avec des tests automatisés puisqu'une partie de la logique, devant être testée, dépend généralement de modification de détails visuels comme la taille d'un champ ou l'emplacement d'un bouton.</li>
<li>Pour la même raison, il devient impossible de passer d'un fonctionement basé sur une interaction humains à une interaction scriptée.</li>
<li>Et pour la même raison encore, il devient difficile, voir impossible, de permettre à ce programme d'être piloté par un autre programme lorsque cela pourra s'averer utile.</li>
</p>

</section>

<section class="original">
<p>The attempted solution, repeated in many organizations, is to create a new layer in the architecture, with the promise that this time, really and truly, no business logic will be put into the new layer. However, having no mechanism to detect when a violation of that promise occurs, the organization finds a few years later that the new layer is cluttered with business logic and the old problem has reappeared.</p>
</section>

<section class="trad">
<p>La tentative de solution, utilisée par de nombreuses organisations, est de créer une nouvelle couche dans l'architecture, avec la promesse que cette fois, “juré craché”, qu'aucune logique métier ne sera présente. Mais comme aucun mécanisme ne permet de détecter que cette promesse est bien respectée, on se rend compte, quelques années plus tard, que la nouvelle couche est parsemée de logique métier et que notre bon vieux problème a réapparu.
</section>

<section class="original">
<p>Imagine now that &#8216;&#8217;every&#8217;&#8217; piece of functionality the application offers were available through an API (application programmed interface) or function call. In this situation, the test or QA department can run automated test scripts against the application to detect when any new coding breaks a previously working function. The business experts can create automated test cases, before the GUI details are finalized, that tells the programmers when they have done their work correctly (and these tests become the ones run by the test department). The application can be deployed in &#8216;&#8217;headless&#8217;&#8217; mode, so only the API is available, and other programs can make use of its functionality &#8212; this simplifies the overall design of complex application suites and also permits business-to-business service applications to use each other without human intervention over the web. Finally, the automated function regression tests detect any violation of the promise to keep business logic out of the presentation layer. The organization can detect, and then correct, the logic leak.</p>
</section>

<section class="trad">
<p>Imaginez maintenant que &#8216;&#8216;chaque&#8217;&#8217; morceau de fonctionalité, que l'application met à disposition, soit disponible à travers une API (Interface de programmation) ou un appel de fonction. Dans ce cas, le département de tests ou de QA (assurance qualité) peux executer des scripts de tests automatisés sur l'application pour détecter si un nouveau développement a cassé un comportement qui marchait précédement. Les experts métiers peuvent créer des cas de tests automatisé, alors que l'interface utilisateur (GUI) n'est pas encore finalisée, et indiquer si les développeurs ont correctement fait leur travail (et ces tests deviennent par la suite ceux utilisés par les départements de tests). L'application peux être deployée en mode &#8216;&#8216;sans interface graphique&#8217;&#8217; et n'être accessible que par appel API, et les autres programmes peuvent encore se servir de ces fonctionnalités -- Cela simplifie la conception globale d'une suite d'applications complexes et permet aussi à des applications de services inter-entreprises d'interagir entre elles sans intervention humaine. Enfin, les tests automatisés de non-régression sur ces API permettent de détecter toute rupture du contrat si une partie de la logique métier a été déplacé dans la couche de présentation[4]. L'organisation peux détecter, et corriger, la fuite de cette logique.</p>

<div class="sidenote">
fn4. La logique métier fait alors défaut dans la couche API. <small>Ceci ne permet pas de detecter qu'aucune logique métier n'est présente dans la couche de présentation. Cela permet de vérifier que s'il y a une logique métier et qu'elle est exprimée au travers de tests, ces tests doivent être satisfait au niveau API. Il est donc important que les tests de la couche API traitent l'ensemble des rêgles métiers.</small>
</div>

</section>

<section class="original">
<p>An interesting similar problem exists on what is normally considered &#8220;the other side&#8221; of the application, where the application logic gets tied to an external database or other service. When the database server goes down or undergoes significant rework or replacement, the programmers can&#8217;t work because their work is tied to the presence of the database. This causes delay costs and often bad feelings between the people.</p>
</section>

<section class="trad">
<p>Un problème similaire existe sur ce qui est normalement considéré comme &#8220;en dehors&#8221; de l'application, lorsque la logique de l'application est liée à une base de données externe ou à tout autre service. Lorsque la base de donnée tombe en panne ou subit un important travail de maintenance ou de modification, les programeurs ne peuvent plus travailler parce que leur travail est lié à la présence de la base de données. Cela occasionne des retards et un mauvais ressenti entre les gens.
</section>


<section class="original">
<p>It is not obvious that the two problems are related, but there is a symmetry between them that shows up in the nature of the solution.</p>
</section>

<section class="trad">
<p>Il n'est pas évident que les deux problèmes soient lié, mais il existe une symétrie entre eux qui se révèle dans la nature de la solution à apporter.</p>
</section>


<section class="original">
<h3>Nature of the Solution </h3>
</section>


<section class="trad">
<h3>Nature de la solution</h3>
</section>


<section class="original">
<p>Both the user-side and the server-side problems actually are caused by the same error in design and programming &#8212; the entanglement between the business logic and the interaction with external entities. The asymmetry to exploit is not that between &#8216;&#8217;left&#8217;&#8217; and &#8216;&#8217;right&#8217;&#8217; sides of the application but between &#8216;&#8217;inside&#8217;&#8217; and &#8216;&#8217;outside&#8217;&#8217; of the application. The rule to obey is that code pertaining to the &#8216;&#8217;inside&#8217;&#8217; part should not leak into the &#8216;&#8217;outside&#8217;&#8217; part.</p>
</section>

<section class="trad">
<div class="sidenote">
fn5. On peux considérer que “ces interactions” correspondent aux solliçations externes comme celles d'un utilisateur via une interface utilisateur, ou un programme via une API. L'auteur évoque donc l'enchevêtrement de cette couche de saisie avec les rêgles métier. 

fn6. Il faut imaginer la séparation comme faisant partie de l'application; la frontière a une épaisseur que l'on peux séparer en deux couches: une couche interieure et une couche exterieure comme un oignon -- voir "jeffreypalermo - L'architecture en oignon":http://jeffreypalermo.com/blog/the-onion-architecture-part-1/
</div>

<p>Tant du côté utilisateur que du côté serveur, les problèmes sont provoqués par la même erreur dans la conception et le développement -- l'enchevêtrement entre la logique métier et les interactions avec les entités externes.[5]
L'asymétrie a exploiter n'est pas entre la partie “gauche" et la partie “droite“ de l'application, mais entre son “interieur" et son “exterieur”. La rêgle à suivre est que le code se rapportant à la partie “interieure” de l'application ne doit pas fuir dans la partie “exterieur”[6].
</p>

</section>

<section class="original">
<p>Removing any left-right or up-down asymmetry for a moment, we see that the application communicates over &#8216;&#8217;ports&#8217;&#8217; to external agencies. The word &#8220;port&#8221; is supposed to evoke thoughts of &#8216;&#8217;ports&#8217;&#8217; in an operating system, where any device that adheres to the protocols of a port can be plugged into it; and &#8216;&#8217;ports&#8217;&#8217; on electronics gadgets, where again, any device that fits the mechanical and electrical protocols can be plugged in. The protocol for a port is given by the purpose of the conversation between the two devices. The protocol takes the form of an application program interface (API).</p>
</section>

<section class="trad">
<p>En supprimant les asymétries gauche-droite ou haut-bas pour un temps, nous voyons que l'application communique via des ports aux organismes externes. Le mot “port” est alors censé évoqué les ports d'un système d'exploitation, où tout dispositif qui adhère au protocol d'un port peut être branché dessus; et les “ports” (ou prises) sur les gadgets électroniques où, la aussi, tout appareil qui remplit les contraintes mécaniques et électriques peut être banché. Le protocole d'un port a pour but de permettre une conversation entre les deux dispositifs. Le protocole prend la forme d'une interface de programmation (API).</p>
</section>

<section class="original">
<p>For each external device there is an &#8216;&#8217;adapter&#8217;&#8217; that converts the API definition to the signals needed by that device and vice versa. A graphical user interface or GUI is an example of an adapter that maps the movements of a person to the API of the port. Other adapters that fit the same port are automated test harnesses such as FIT or Fitnesse, batch drivers, and any code needed for communication between applications across the enterprise or net.</p>
</section>

<section class="trad">
<p>Pour chaque périphérique externe, il y a un “adaptateur” qui convertit la définition de l'API en signaux requis par ce périphérique et réciproquement. Une interface graphique utilisateur ou GUI est un exemple d'adaptateur qui fait correspondre les mouvements d'une personne à l'API du port. Il existe d'autres adaptateurs qui s'adaptent au même port, tels que les harnais de tests automatisés comme FIT ou Fitnesse[7], les pilotes[8] de scripts, et tout autre code nécessaire pour la communication entre applications dans l'entreprise ou le réseau.</p>
<div class="sidenote">
fn7. "FitNesse":http://fitnesse.org/FitNesse.UserGuide.OneMinuteDescription (basé sur "Framework for Integrated Test -- FIT":http://fitnesse.org/FitNesse.UserGuide.FitFramework) est un environement collaboratif permettant l'écriture de tests fonctionnels à travers un wiki.

fn8. Un pilote (ou driver) est un programme, destiné à permettre à un autre programme (souvent un système d'exploitation) d'interagir avec un périphérique. ; par extension ce mot est aussi utilisé pour décrire un adaptateur.

fn9. La traduction de “mock” en “bouchon” ne reflète pas toujours l'idée sous-jacente qu'il transmet, d'autant plus qu'il existe plusieurs definitions et plusieurs concepts qui y sont liés: mock, stub... Je conseille la lecture de "Mocks Aren't Stubs - Martin Fowler":http://martinfowler.com/articles/mocksArentStubs.html afin de mieux cerner les différences qui existent. J'ai donc opter pour “simulacre” qui, selon wikipedia, <quote>désigne une apparence qui ne renvoie à aucune réalité sous-jacente, et prétend valoir pour cette réalité elle-même.</quote>

fn10. On retrouve généralement les couches: sécurité, présentation, application ou service, domaine ou métier, infrastructure, données... Il s'agit d'une architecture mono-dimensionelle puisqu'une couche n'interagit qu'avec les couches qui l'entourent: une couche au-dessus et une couche en-dessous façon sandwich.

</div>
</section>

<section class="original">
<p>On another side of the application, the application communicates with an external entity to get data. The protocol is typically a database protocol. From the application&#8217;s perspective, if the database is moved from a SQL database to a flat file or any other kind of database, the conversation across the API should not change. Additional adapters for the same port thus include an SQL adapter, a flat file adapter, and most importantly, an adapter to a &#8220;mock&#8221; database, one that sits in memory and doesn&#8217;t depend on the presence of the real database at all.</p>
</section>

<section class="trad">
<p>Une autre partie de l'application, quant a elle, communique avec une entité externe pour obtenir des données. Le protocole correspond généralement à celui d'une base de données. D'un point de vue de l'application, si la source de données passe d'une base de données SQL à un fichier plat ou n'importe quel autre type de base de données, la conversation à travers l'API ne devrait pas changer. Les adaptateurs pour ce port incluent donc: un adaptateur SQL, un adaptateur pour fichier plat, et plus important encore, un adaptateur pour un “simulacre”[9] de base de données, qui réside en mémoire et ne dépend pas de la présence de la véritable base de données.</p>
</section>

<section class="original">
<p>Many applications have only two ports: the user-side dialog and the database-side dialog. This gives them an asymmetric appearance, which makes it seem natural to build the application in a one-dimensional, three-, four-, or five-layer stacked architecture.</p>
</section>

<section class="trad">
<p>Beaucoup d'applications n'ont que deux ports: les interactions avec l'utilisateur et les interactions avec la base de données. Cela leur donne un aspect asymétrique qui semble naturel pour construire une architecture unidimensionelle à trois, quatre ou cinq couches.[10]</p>
</section>

<section class="original">
<p>There are two problems with these drawings. First and worst, people tend not to take the &#8220;lines&#8221; in the layered drawing seriously. They let the application logic leak across the layer boundaries, causing the problems mentioned above. Secondly, there may be more than two ports to the application, so that the architecture does not fit into the one-dimensional layer drawing.</p>
</section>

<section class="trad">
<p>Il y a deux problèmes avec cette schématisation. La première, et la pire, est que les gens ne prennent pas au sérieux les “lignes” séparant les couches. Ils laissent la logique de l'application traverser les frontières, causant les problèmes mentionnés précédement. Deuxièmement, il peut y avoir plus de deux ports à l'application, de sorte que l'architecture ne s'insère plus dans le schéma unidimensionnel en couche.</p>
</section>

<section class="original">
<p>The hexagonal, or ports and adapters, architecture solves these problems by noting the symmetry in the situation: there is an application on the inside communicating over some number of ports with things on the outside. The items outside the application can be dealt with symmetrically.</p>
</section>

<section class="trad">
<p>L'architecture hexagonale, ou ports et adaptateurs, résout ces problématiques en prenant en compte la symétrie de la situation: il y a une application à l'interieur communiquant via plusieurs ports avec des choses à l'exterieur. Les choses à l'exterieur peuvent être traitées de la même façon par symétrie.[11]</p>

<div class="sidenote">
fn11. En regardant les figures 1 et 2, l'espace entre l'hexagone "Application" et l'hexagone extérieur sert à adapter l'application avec son environement. La face de l'hexagone correspond au ”port”, l'adaptateur relie alors cette face avec le périphérique externe.
</div>
</section>

<section class="original">
<p>The hexagon is intended to visually highlight</p>
</section>

<p class="trad"> L'hexagone est destiné à mettre en évidence visuellement</p>

<section class="original">
<p>(a) the inside-outside asymmetry and the similar nature of ports, to get away from the one-dimensional layered picture and all that evokes, and</p>
</section>

<section class="trad">
<p>(a) l'asymétrie interieure-exterieure et la nature similaire des ports, s'éloigner du schéma mono-dimensionnel à couche et tout ce qu'il évoque, et</p>
</section>

<section class="original">
<p>(b) the presence of a defined number of different ports &#8211; two, three, or four (four is most I have encountered to date).</p>
</section>

<section class="trad">
<p>(b) la présence d'un nombre définit de ports -- deux, trois, ou quatre (quatre est le maximum que j'ai rencontré jusqu'à présent).</p>
</section>

<section class="original">
<p>The hexagon is not a hexagon because the number six is important, but rather to allow the people doing the drawing to have room to insert ports and adapters as they need, not being constrained by a one-dimensional layered drawing. The term &#8216;&#8217;hexagonal architecture&#8217;&#8217; comes from this visual effect.</p>
</section>

<section class="trad">
<p>L'hexagone n'est pas un hexagone car le nombre six est important, mais parce qu'il permet aux personnes qui le dessinent d'avoir de la place pour insérer les ports et les adaptateurs selon leurs besoins, sans être contraint par une representation monodimensionnelle en couche. Le terme “architecture hexagonale” trouve son origine dans cet effet visuel.</p></section>

<section class="original">
<p>The term &#8220;port and adapters&#8221; picks up the &#8216;&#8217;purposes&#8217;&#8217; of the parts of the drawing. A port identifies a purposeful conversation. There will typically be multiple adapters for any one port, for various technologies that may plug into that port. Typically, these might include a phone answering machine, a human voice, a touch-tone phone, a graphical human interface, a test harness, a batch driver, an http interface, a direct program-to-program interface, a mock (in-memory) database, a real database (perhaps different databases for development, test, and real use).</p>
</section>

<section class="trad">
<p>Le terme “port et adaptateurs” prend son sens dans les différentes parties du schéma. Un port identifie une conversation bien définie. Il y a généralement plusieurs adapatateurs pour un seul port, et ce, pour les différentes technologies qui peuvent se brancher sur ce port. Typiquement, cela peux inclure un répondeur téléphonique, une voix humaine, un clavier de téléphone, une interface graphique, un logiciel de validation, un traitement par lot, une interface HTTP, une connexion directe programme à programme, un simulacre[9] (en mêmoire) de base de données, une véritable base de données (pouvant être différentes pour les phases de développement, de tests, et d'utilisation réelle).</p>
</section>

<section class="original">
<p>In the Application Notes, the left-right asymmetry will be brought up again. However, the primary purpose of this pattern is to focus on the inside-outside asymmetry, pretending briefly that all external items are identical from the perspective of the application.</p>
</section>

<p class="google_trad"> Dans les notes d'application, l'asymétrie gauche-droite sera à nouveau évoquée. Cependant, le but principal de ce modèle est de se concentrer sur l'asymétrie dedans-dehors, semblant brièvement que tous les éléments extérieurs sont identiques du point de vue de l'application.</p>

<p class="yahoo_trad"> Dans les notes d'application, l'asymétrie de gauche à droite sera évoquée encore. Cependant, le but primaire de ce modèle est de se concentrer sur l'asymétrie d'à l'intérieur-extérieur, feignant brièvement que tous les articles externes sont identiques de la perspective de l'application.</p>

<section class="original">
<h3>Structure </h3>
</section>

<p><img src='/images/hexagonal-architecture/2302' alt='Image177.gif' title='Image177.gif' /><br /><br />
 Figure 2</p>

<section class="original">
<p>Figure 2 shows an application having two active ports and several adapters for each port. The two ports are the application-controlling side and the data-retrieval side. This drawing shows that the application can be equally driven by an automated, system-level regression test suite, by a human user, by a remote http application, or by another local application. On the data side, the application can be configured to run decoupled from external databases using an in-memory oracle, or &#8216;&#8217;mock&#8217;&#8217;, database replacement; or it can run against the test- or run-time database. The functional specification of the application, perhaps in use cases, is made against the inner hexagon&#8217;s interface and not against any one of the external technologies that might be used.</p>
</section>

<p class="google_trad"> La figure 2 montre une application possédant deux ports actifs et plusieurs adaptateurs pour chaque port. Les deux ports sont du côté de l'application sans contrôle et le côté d'extraction de données. Ce dessin montre que l'application peut être également piloté par un système automatisé de niveau suite de tests de régression, par un utilisateur humain, par une application distante http, ou par une autre application locale. Sur le côté des données, l'application peut être configurée pour fonctionner découplée de bases de données externes en utilisant un en mémoire oracle, ou''maquette''de remplacement de bases de données, ou il peut courir contre la base de données de test ou de l'exécution. La spécification fonctionnelle de l'application, peut-être en cas d'utilisation, l'interface est faite contre l'hexagone intérieur et non pas contre l'une des technologies externes qui pourraient être utilisés.</p>

<p class="yahoo_trad"> Le schéma 2 montre une application ayant deux ports actifs et plusieurs adapteurs pour chaque port. Les deux ports sont le côté de application-contrôle et le côté de donnée-récupération. Ce schéma prouve que l'application peut être également conduite par automatisé, suite d'essai au niveau système de régression, par un utilisateur humain, par une application à distance de HTTP, ou par une autre application locale. Du côté de données, l'application peut être configurée à la course découplée des bases de données externes utilisant un oracle de dans-mémoire, ou mock'de `au ', remplacement de base de données ; ou elle peut fonctionner contre la base de données d'essai ou d'exécution. Les spécifications fonctionnelles de l'application, peut-être en service des cas, sont faites contre l'interface de l'hexagone intérieur et pas contre des n'importe quelles des technologies externes qui pourraient être employées.</p>

<section class="original">
<p><img src='/images/hexagonal-architecture/2303' alt='Hexagonal architecture barn door image.gif' title='Hexagonal architecture barn door image.gif' /><br /><br />
 Figure 3</p>
</section>

<section class="original">
<p>Figure 3 shows the same application mapped to a three-layer architectural drawing. To simplify the drawing only two adapters are shown for each port. This drawing is intended to show how multiple adapters fit in the top and bottom layers, and the sequence in which the various adapters are used during system development. The numbered arrows show the order in which a team might develop and use the application:</p>
</section>

<p class="google_trad"> La figure 3 montre la même application mappée sur un dessin à trois couches architecturales. Pour simplifier le dessin que deux adaptateurs sont présentés pour chaque port. Ce dessin est destiné à montrer comment de multiples adaptateurs ajustement dans les couches supérieures et inférieures, et la séquence dans laquelle les différents adaptateurs sont utilisés pendant le développement du système. Les flèches numérotées indiquent l'ordre dans lequel une équipe peut développer et utiliser l'application:</p>

<p class="yahoo_trad"> Le schéma 3 montre la même application tracée à un schéma architectural de trois-couche. Pour simplifier le schéma seulement deux adapteurs sont montrés pour chaque port. Ce schéma est prévu pour montrer comment les adapteurs multiples adaptés dans les couches de dessus et de bas, et l'ordre dans lequel les divers adapteurs sont utilisés pendant le développement de système. Les flèches numérotées montrent l'ordre dans lequel une équipe pourrait se développer et emploient l'application :</p>


<section class="original">
<ol>
<li>With a FIT test harness driving the application and using the mock (in-memory) database substituting for the real database;</li>
<li>Adding a GUI to the application, still running off the mock database;</li>
<li>In integration testing, with automated test scripts (e.g., from Cruise Control) driving the application against a real database containing test data;</li>
<li>In real use, with a person using the application to access a live database.</li>
</ol>
</section>

<p class="google_trad"> 
# Avec un harnais de test FIT conduire à l'application et l'utilisation de la maquette (en mémoire) base de données substituant à la base de données réelles;
# Ajout d'une interface graphique à l'application, encore en cours au large de la base de données se moquer;
# Dans les tests d'intégration, avec des scripts de test automatisés (par exemple, de Cruise Control) de conduire l'application contre une véritable base de données contenant les données d'essai;
# En utilisation réelle, avec une personne utilisant l'application pour accéder à une base de données en direct.
</p>

<p class="yahoo_trad"> 
# Avec un logiciel de validation d'AJUSTEMENT conduisant l'application et employant la fausse base de données (de dans-mémoire) remplaçant la vraie base de données ;
# Ajouter un GUI à l'application, coulant toujours de la fausse base de données ;
# Dans l'essai d'intégration, avec les manuscrits automatisés d'essai (par exemple, de la commande de croisière) conduisant l'application contre une vraie base de données contenant des essais ;
# Dans la vraie utilisation, avec une personne employant l'application pour accéder à une base de données de phase.
</p>

<section class="original">
<h3>Sample Code </h3>
</section>

<section class="original">
<p>The simplest application that demonstrates the ports &amp; adapters fortunately comes with the FIT documentation. It is a simple discount computing application:</p>
</section>

<section class="original">
<pre>
discount(amount) = amount * rate(amount);
</pre>
</section>

<section class="original">
<p>In our adaptation, the amount will come from the user and the rate will come from a database, so there will be two ports. We implement them in stages:</p>
</section>

<section class="original">
<ul>
<li>With tests but with a constant rate instead of a mock database,</li>
<li>then with the GUI,</li>
<li>then with a mock database that can be swapped out for a real database.</li>
</ul>
</section>

<section class="original">
<p><em>Thanks to Gyan Sharma at IHC for providing the code for this example.</em></p>
</section>

<section class="original">
<h4>Stage 1: FIT <ins> App </ins> constant-as-mock-database</h4>
</section>

<section class="original">
<p>First we create the test cases as an HTML table (see the FIT documentation for this):</p>
</section>

<section class="original">
<table>
<tr>
<td> TestDiscounter </td><td> </td>
</tr>
<tr>
<td> amount  </td><td> discount() </td>
</tr>
<tr>
<td> 100  </td><td> 5 </td>
</tr>
<tr>
<td> 200  </td><td>10 </td>
</tr>
</table>
</section>

<section class="original">
<p>Note that the column names will become class and function names in our program. FIT contains ways to get rid of this &#8220;programmerese&#8221;, but for this article it is easier just to leave them in.</p>
</section>

<section class="original">
<p>Knowing what the test data will be, we create the user-side adapter, the ColumnFixture that comes with FIT as shipped:</p>
</section>

<section class="original">
<pre>
import fit.ColumnFixture; 
public class TestDiscounter extends ColumnFixture 
{ 
   private Discounter app = new Discounter(); 
   public double amount;
   public double discount() 
   { return app.discount(amount); } 
}
</pre>
</section>

<section class="original">
<p>That&#8217;s actually all there is to the adapter. So far, the tests run from the command line (see the FIT book for the path you&#8217;ll need). We used this one:</p>
</section>

<section class="original">
<pre>
set FIT_HOME=/FIT/FitLibraryForFit15Feb2005
java -cp %FIT_HOME%/lib/javaFit1.1b.jar;%FIT_HOME%/dist/fitLibraryForFit.jar;src;bin
fit.FileRunner test/Discounter.html TestDiscount_Output.html
</pre>
</section>

<section class="original">
<p>FIT produces an output file with colors showing us what passed (or failed, in case we made a typo somewhere along the way).</p>
<p>At this point the code is ready to check in, hook into Cruise Control or your automated build machine, and include in the build-and-test suite.</p>
</section>

<section class="original">
<h4>Stage 2: UI <ins> App </ins> constant-as-mock-database </h4>
</section>

<section class="original">
<p>I&#8217;m going to let you create your own UI and have it drive the Discounter application, since the code is a bit long to include here. Some of the key lines in the code are these:</p>
</section>

<section class="original">
<pre>
...
 Discounter app = new Discounter();
public void actionPerformed(ActionEvent event) 
{
    ...
   String amountStr = text1.getText();
   double amount = Double.parseDouble(amountStr);
   discount = app.discount(amount));
   text3.setText( "" + discount );
   ...
</pre>
</section>

<section class="original">
<p>At this point the application can be both demoed and regression tested. The user-side adapters are both running.</p>
</section>

<section class="original">
<h4>Stage 3: (FIT or UI) <ins> App </ins> mock database </h4>
</section>

<section class="original">
<p>To create a replaceable adapter for the database side, we create an &#8216;&#8217;interface&#8217;&#8217; to a repository, a &#8216;&#8217;RepositoryFactory&#8217;&#8217; that will produce either the mock database or the real service object, and the in-memory mock for the database.</p>
</section>

<section class="original">
<pre>
public interface RateRepository 
{
   double getRate(double amount);
 }
public class RepositoryFactory 
{
   public RepositoryFactory() {  super(); }
   public static RateRepository getMockRateRepository() 
   {
      return new MockRateRepository();
   }
}
public class MockRateRepository implements RateRepository 
{
   public double getRate(double amount) 
   {
      if(amount &lt;= 100) return 0.01;
      if(amount &lt;= 1000) return 0.02;
      return 0.05;
    }
 }
</pre>
</section>

<section class="original">
<p>To hook this adapter into the Discounter application, we need to update the application itself to accept a repository adapter to use, and the have the (FIT or UI) user-side adapter pass the repository to use (real or mock) into the constructor of the application itself. Here is the updated application and a FIT adapter that passes in a mock repository (the FIT adapter code to choose whether to pass in the mock or real repository&#8217;s adapter is longer without adding much new information, so I omit that version here).</p>
</section>

<section class="original">
<pre>
import repository.RepositoryFactory;
import repository.RateRepository;
public class Discounter 
{
   private RateRepository rateRepository;
   public Discounter(RateRepository r) 
   {
      super();
      rateRepository = r;
    }
   public double discount(double amount) 
   {
      double rate = rateRepository.getRate( amount ); 
      return amount * rate;
    }
}
import app.Discounter;
import fit.ColumnFixture;
public class TestDiscounter extends ColumnFixture 
{
   private Discounter app = 
       new Discounter(RepositoryFactory.getMockRateRepository());
   public double amount;
   public double discount() 
   {
      return app.discount( amount );
   }
}
</pre>
</section>

<section class="original">
<p>That concludes implementation of the simplest version of the hexagonal architecture.</p>
</section>

<section class="original">
<h3>Application Notes </h3>
</section>

<section class="original">
<h4>The Left-Right Asymmetry </h4>
</section>

<section class="original">
<p>The ports and adapters pattern is deliberately written pretending that all ports are fundamentally similar. That pretense is useful at the architectural level. In implementation, ports and adapters show up in two flavors, which I&#8217;ll call &#8216;&#8217;primary&#8217;&#8217; and &#8216;&#8217;secondary&#8217;&#8217;, for soon-to-be-obvious reasons. They could be also called &#8216;&#8217;driving&#8217;&#8217; adapters and &#8216;&#8217;driven&#8217;&#8217; adapters.</p>
</section>

<section class="original">
<p>The alert reader will have noticed that in all the examples given, FIT fixtures are used on the left-side ports and mocks on the right. In the three-layer architecture, FIT sits in the top layer and the mock sits in the bottom layer.</p>
</section>

<section class="original">
<p>This is related to the idea from use cases of &#8220;primary actors&#8221; and &#8220;secondary actors&#8221;. A &#8216;&#8217;primary actor&#8217;&#8217; is an actor that drives the application (takes it out of quiescent state to perform one of its advertised functions). A &#8216;&#8217;secondary actor&#8217;&#8217; is one that the application drives, either to get answers from or to merely notify. The distinction between &#8216;&#8217;primary &#8216;&#8217;and&#8217;&#8217; secondary &#8216;&#8217;lies in who triggers or is in charge of the conversation.</p>
</section>

<section class="original">
<p>The natural test adapter to substitute for a &#8216;&#8217;primary&#8217;&#8217; actor is FIT, since that framework is designed to read a script and drive the application. The natural test adapter to substitute for a &#8216;&#8217;secondary&#8217;&#8217; actor such as a database is a mock, since that is designed to answer queries or record events from the application.</p>
</section>

<section class="original">
<p>These observations lead us to follow the system&#8217;s use case context diagram and draw the &#8216;&#8217;primary ports &#8216;&#8217;and&#8217;&#8217; primary adapters&#8217;&#8217; on the left side (or top) of the hexagon, and the &#8216;&#8217;secondary ports&#8217;&#8217; and &#8216;&#8217;secondary adapters&#8217;&#8217; on the right (or bottom) side of the hexagon.</p>
</section>

<section class="original">
<p>The relationship between primary and secondary ports/adapters and their respective implementation in FIT and mocks is useful to keep in mind, but it should be used as a consequence of using the ports and adapters architecture, not to short-circuit it. The ultimate benefit of a ports and adapters implementation is the ability to run the application in a fully isolated mode.</p>
</section>

<section class="original">
<h4>Use Cases And The Application Boundary </h4>
</section>

<section class="original">
<p>It is useful to use the hexagonal architecture pattern to reinforce the preferred way of writing use cases.</p>
</section>

<section class="original">
<p>A common mistake is to write use cases to contain intimate knowledge of the technology sitting outside each port. These use cases have earned a justifiably bad name in the industry for being long, hard-to-read, boring, brittle, and expensive to maintain.</p>
</section>

<section class="original">
<p>Understanding the ports and adapters architecture, we can see that the use cases should generally be written at the application boundary (the inner hexagon), to specify the functions and events supported by the application, regardless of external technology. These use cases are shorter, easier to read, less expensive to maintain, and more stable over time.</p>
</section>

<section class="original">
<h4>How Many Ports? </h4>
</section>

<section class="original">
<p>What exactly a port is and isn&#8217;t is largely a matter of taste. At the one extreme, every use case could be given its own port, producing hundreds of ports for many applications. Alternatively, one could imagine merging all primary ports and all secondary ports so there are only two ports, a left side and a right side.</p>
</section>

<section class="original">
<p>Neither extreme appears optimal.</p>
</section>

<section class="original">
<p>The weather system described in the Known Uses has four natural ports: the weather feed, the administrator, the notified subscribers, the subscriber database. A coffee machine controller has four natural ports: the user, the database containing the recipes and prices, the dispensers, and the coin box. A hospital medication system might have three: one for the nurse, one for the prescription database, and one for the computer-controller medication dispensers.</p>
</section>

<section class="original">
<p>It doesn&#8217;t appear that there is any particular damage in choosing the &#8220;wrong&#8221; number of ports, so that remains a matter of intuition. My selection tends to favor a small number, two, three or four ports, as described above and in the Known Uses.</p>
</section>

<section class="original">
<h3>Known Uses </h3>
</section>

<section class="original">
<p><img src='/images/hexagonal-architecture/2304' alt='Image179.gif' title='Image179.gif' /><br /><br />
 Figure 4</p>
</section>

<section class="original">
<p>Figure 4 shows an application with four ports and several adapters at each port. This was derived from an application that listened for alerts from the national weather service about earthquakes, tornadoes, fires and floods, and notified people on their telephones or telephone answering machines. At the time we discussed this system, the system&#8217;s interfaces were identified and discussed by &#8216;&#8217;technology, linked to purpose&#8217;&#8217;. There was an interface for trigger-data arriving over a wire feed, one for notification data to be sent to answering machines, an administrative interface implemented in a GUI, and a database interface to get their subscriber data.</p>
</section>

<section class="original">
<p>The people were struggling because they needed to add an http interface from the weather service, an email interface to their subscribers, and they had to find a way to bundle and unbundle their growing application suite for different customer purchasing preferences. They feared they were staring at a maintenance and testing nightmare as they had to implement, test and maintain separate versions for all combinations and permutations.</p>
</section>

<section class="original">
<p>Their shift in design was to architect the system&#8217;s interfaces &#8216;&#8217;by purpose&#8217;&#8217; rather than by technology, and to have the technologies be substitutable (on all sides) by adapters. They immediately picked up the ability to include the http feed and the email notification (the new adapters are shown in the drawing with dashed lines). By making each application executable in headless mode through APIs, they could add an app-to-add adapter and unbundle the application suite, connecting the sub-applications on demand. Finally, by making each application executable completely in isolation, with test and mock adapters in place, they gained the ability to regression test their applications with stand-alone automated test scripts.</p>
</section>

<section class="original">
<h4>Mac, Windows, Google, Flickr, Web 2.0 </h4>
</section>

<section class="original">
<p>In the early 1990s, MacIntosh applications such as word processor applications were required to have API-drivable interfaces, so that applications and user-written scripts could access all the functions of the applications. Windows desktop applications have evolved the same ability (I don&#8217;t have the historical knowledge to say which came first, nor is that relevant to the point).</p>
</section>

<section class="original">
<p>The current (2005) trend in web applications is to publish an API and let other web applications access those APIs directly. Thus, it is possible to publish local crime data over a Google map, or create web applications that include Flickr&#8217;s photo archiving and annotating abilities.</p>
</section>

<section class="original">
<p>All of these examples are about making the &#8216;&#8217;primary &#8216;&#8217;ports&#8217; APIs visible. We see no information here about the secondary ports.</p>
</section>

<section class="original">
<h4>Stored Outputs </h4>
</section>

<section class="original">
<p>This example written by Willem Bogaerts on the C2 wiki:</p>
</section>

<section class="original">
<p>&#8220;I encountered something similar, but mainly because my application layer had a strong tendency to become a telephone switchboard that managed things it should not do. My application generated output, showed it to the user and then had some possibility to store it as well. My main problem was that you did not need to store it always. So my application generated output, had to buffer it and present it to the user. Then, when the user decided that he wanted to store the output, the application retrieved the buffer and stored it for real.</p>
</section>

<section class="original">
<p>I did not like this at all. Then I came up with a solution: Have a presentation control with storage facilities. Now the application no longer channels the output in different directions, but it simply outputs it to the presentation control. It&#8217;s the presentation control that buffers the answer and gives the user the possibility to store it.</p>
</section>

<section class="original">
<p>The traditional layered architecture stresses &#8220;UI&#8221; and &#8220;storage&#8221; to be different. The Ports and Adapters Architecture can reduce output to being simply &#8220;output&#8221; again. &#8221; </p>
</section>

<section class="original">
<h4>Anonymous example from the C2-wiki </h4>
</section>

<section class="original">
<p>&#8220;In one project I worked on, we used the SystemMetaphor of a component stereo system. Each component has defined interfaces, each of which has a specific purpose. We can then connect components together in almost unlimited ways using simple cables and adapters.&#8221; </p>
</section>

<section class="original">
<h4>Distributed, Large-Team Development </h4>
</section>

<section class="original">
<p>This one is still in trial use and so does not properly count as a use of the pattern. However, it is interesting to consider.</p>
</section>

<section class="original">
<p>Teams in different locations all build to the Hexagonal architecture, using FIT and mocks so the applications or components can be tested in standalone mode. The CruiseControl build runs every half hour and runs all the applications using the FIT+mock combination. As application subsystem and databases get completed, the mocks are replaced with test databases.</p>
</section>

<section class="original">
<h4>Separating Development of UI and Application Logic </h4>
</section>

<section class="original">
<p>This one is still in early trial use and so does not count as a use of the pattern. However, it is interesting to consider.</p>
</section>

<section class="original">
<p>The UI design is unstable, as they haven&#8217;t decided on a driving technology or a metaphor yet. The back-end services architecture hasn&#8217;t been decided, and in fact will probably change several times over the next six months. Nonetheless, the project has officially started and time is ticking by.</p>
</section>

<section class="original">
<p>The application team creates FIT tests and mocks to isolate their application, and creates testable, demonstrable functionality to show their users. When the UI and back-end services decisions finally get met, it &#8220;should be straightforward&#8221; to add those elements the application. Stay tuned to learn how this works out (or try it yourself and write me to let me know).</p>
</section>

<section class="original">
<h3>Related Patterns </h3>
</section>

<section class="original">
<h4>Adapter </h4>
</section>

<section class="original">
<p>The &#8216;&#8217;Design Patterns&#8217;&#8217; book contains a description of the generic &#8216;&#8217;Adapter&#8217;&#8217; pattern: &#8220;Convert the interface of a class into another interace clients expect.&#8221; The ports-and-adapters pattern is a particular use of the &#8216;&#8217;Adapter&#8217;&#8217; pattern.</p>
</section>

<section class="original">
<h4>Model-View-Controller </h4>
</section>

<section class="original">
<p>The MVC pattern was implemented as early as 1974 in the Smalltalk project. It has been given, over the years, many variations, such as Model-Interactor and Model-View-Presenter. Each of these implements the idea of ports-and-adapters on the primary ports, not the secondary ports.</p>
</section>

<section class="original">
<h4>Mock Objects and Loopback </h4>
</section>

<section class="original">
<p>&#8220;A mock object is a &#8220;double agent&#8221; used to test the behaviour of other objects. First, a mock object acts as a faux implementation of an interface or class that mimics the external behaviour of a true implementation. Second, a mock object observes how other objects interact with its methods and compares actual behaviour with preset expectations. When a discrepancy occurs, a mock object can interrupt the test and report the anomaly. If the discrepancy cannot be noted during the test, a verification method called by the tester ensures that all expectations have been met or failures reported.&#8221; &#8212; From <a href="http://MockObjects.com" target="_blank">http://MockObjects.com</a></p>
</section>

<section class="original">
<p>Fully implemented according to the mock-object agenda, mock objects are used throughout an application, not just at the external interface The primary thrust of the mock object movement is conformance to specified protocol at the individual class and object level. I borrow their word &#8220;mock&#8221; as the best short description of an in-memory substitute for an external secondary actor.</p>
</section>

<section class="original">
<p>The Loopback pattern is an explicit pattern for creating an internal replacement for an external device.</p>
</section>

<section class="original">
<h4>Pedestals </h4>
</section>

<section class="original">
<p>In &#8220;Patterns for Generating a Layered Architecture&#8221;, Barry Rubel describes a pattern about creating an axis of symmetry in control software that is very similar to ports and adapters. The &#8216;&#8217;Pedestal&#8217;&#8217; pattern calls for implementing an object representing each hardware device within the system, and linking those objects together in a control layer. The &#8216;&#8217;Pedestal&#8217;&#8217; pattern can be used to describe either side of the hexagonal architecture, but does not yet stress the similarity across adapters. Also, being written for a mechanical control environment, it is not so easy to see how to apply the pattern to IT applications.</p>
</section>

<section class="original">
<h4>Checks </h4>
</section>

<section class="original">
<p>Ward Cunningham&#8217;s pattern language for detecting and handling user input errors, is good for error handling across the inner hexagon boundaries.</p>
</section>

<section class="original">
<h4>Dependency Inversion (Dependency Injection) and SPRING </h4>
</section>

<section class="original">
<p>Bob Martin&#8217;s Dependency Inversion Principle (also called Dependency Injection by Martin Fowler) states that &#8220;High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.&#8221; The &#8216;&#8217;Dependency Injection &#8216;&#8217;pattern by Martin Fowler gives some implementations. These show how to create swappable secondary actor adapters. The code can be typed in directly, as done in the sample code in the article, or using configuration files and having the SPRING framework generate the equivalent code.</p>
</section>

<section class="original">
<h3>Acknowledgements </h3>

(omitted for clarity)

<h3>References and Related Reading </h3>

(omitted for clarity)
</section>

